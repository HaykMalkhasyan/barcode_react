{"ast":null,"code":"import _objectSpread from \"C:\\\\Users\\\\User\\\\Desktop\\\\barcode\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectSpread\";\nimport _slicedToArray from \"C:\\\\Users\\\\User\\\\Desktop\\\\barcode\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"C:\\\\Users\\\\User\\\\Desktop\\\\barcode\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/objectWithoutProperties\";\nimport Immutable from 'immutable';\nvar pending = Immutable.Map();\nexport default function apiClientMiddleware(apiClient) {\n  return function (_ref) {\n    var getState = _ref.getState,\n        dispatch = _ref.dispatch;\n    return function (next) {\n      return function (action) {\n        if (typeof action === 'function') {\n          return action(dispatch, getState);\n        }\n\n        var promise = action.promise,\n            types = action.types,\n            upload = action.upload,\n            rest = _objectWithoutProperties(action, [\"promise\", \"types\", \"upload\"]);\n\n        if (!Array.isArray(types) && promise) {\n          return Promise.resolve(promise().then(function () {\n            next(action);\n          }));\n        }\n\n        if (!promise) {\n          return next(action);\n        } // get the request data\n\n\n        var _types = _slicedToArray(types, 3),\n            REQUEST = _types[0],\n            FAILURE = _types[1],\n            SUCCESS = _types[2];\n\n        if (promise && upload) {\n          var PROGRESS = types[3];\n          console.log(PROGRESS);\n          apiClient.setConfig('onUploadProgress', function (progressEvent) {\n            next(_objectSpread({}, rest, {\n              type: PROGRESS,\n              progressEvent: progressEvent\n            }));\n          });\n        } // if there is a pending request of the same type\n        // use that instead for a queue\n\n\n        var resolvePromise = null;\n\n        if (pending.has(REQUEST)) {\n          resolvePromise = pending.get(REQUEST).then(function () {\n            //fire the request itself\n            next(_objectSpread({}, rest, {\n              type: REQUEST\n            }));\n            return Promise.resolve(promise(apiClient, getState).then(function (result) {\n              // clear this promise from the queue\n              pending = pending.remove(REQUEST);\n              apiClient.resetConfigs(); // send back a success result\n\n              return next(_objectSpread({}, rest, {\n                result: result,\n                type: SUCCESS\n              }));\n            }).catch(function (error) {\n              // clear this promise from the queue\n              pending = pending.remove(REQUEST);\n              apiClient.resetConfigs(); // send back an error result\n\n              return next(_objectSpread({}, rest, {\n                error: error,\n                type: FAILURE\n              }));\n            }));\n          });\n        } else {\n          // fire off the request to show we are making this request\n          next(_objectSpread({}, rest, {\n            type: REQUEST\n          }));\n          resolvePromise = promise(apiClient, getState).then(function (result) {\n            apiClient.resetConfigs(); // clear this promise from the queue\n\n            pending = pending.remove(REQUEST); // send back a success result\n\n            return next(_objectSpread({}, rest, {\n              result: result,\n              type: SUCCESS\n            }));\n          }).catch(function (error) {\n            // clear this promise from the queue\n            pending = pending.remove(REQUEST);\n            apiClient.resetConfigs(); // send back an error result\n\n            return next(_objectSpread({}, rest, {\n              error: error,\n              type: FAILURE\n            }));\n          });\n        } // set this as request type as pending\n\n\n        pending = pending.set(REQUEST, resolvePromise);\n        return resolvePromise;\n      };\n    };\n  };\n}","map":{"version":3,"sources":["C:/Users/User/Desktop/barcode/src/redux/middlewares/apiMiddleware.js"],"names":["Immutable","pending","Map","apiClientMiddleware","apiClient","getState","dispatch","next","action","promise","types","upload","rest","Array","isArray","Promise","resolve","then","REQUEST","FAILURE","SUCCESS","PROGRESS","console","log","setConfig","progressEvent","type","resolvePromise","has","get","result","remove","resetConfigs","catch","error","set"],"mappings":"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","sourcesContent":["import Immutable from 'immutable';\r\n\r\nlet pending = Immutable.Map();\r\n\r\nexport default function apiClientMiddleware(apiClient) {\r\n    return ({getState, dispatch}) => {\r\n        return next => action => {\r\n            if (typeof action === 'function') {\r\n                return action(dispatch, getState);\r\n            }\r\n            const {promise, types, upload, ...rest} = action;\r\n\r\n            if (!Array.isArray(types) && promise) {\r\n                return Promise.resolve(promise().then(() => {\r\n                    next(action);\r\n                }));\r\n            }\r\n\r\n            if (!promise) {\r\n                return next(action);\r\n            }\r\n\r\n            // get the request data\r\n            const [REQUEST, FAILURE ,SUCCESS] = types;\r\n\r\n            if (promise && upload) {\r\n                const PROGRESS = types[3];\r\n                console.log(PROGRESS);\r\n                apiClient.setConfig('onUploadProgress', (progressEvent) => {\r\n                    next({...rest, type: PROGRESS, progressEvent});\r\n                })\r\n            }\r\n\r\n            // if there is a pending request of the same type\r\n            // use that instead for a queue\r\n            let resolvePromise = null;\r\n            if (pending.has(REQUEST)) {\r\n                resolvePromise = pending.get(REQUEST)\r\n                    .then(() => {\r\n                        //fire the request itself\r\n                        next({...rest, type: REQUEST});\r\n\r\n                        return Promise.resolve(\r\n                            promise(apiClient, getState)\r\n                                .then(result => {\r\n                                    // clear this promise from the queue\r\n                                    pending = pending.remove(REQUEST);\r\n                                    apiClient.resetConfigs();\r\n                                    // send back a success result\r\n                                    return next({...rest, result, type: SUCCESS});\r\n                                })\r\n                                .catch(error => {\r\n                                    // clear this promise from the queue\r\n                                    pending = pending.remove(REQUEST);\r\n                                    apiClient.resetConfigs();\r\n                                    // send back an error result\r\n                                    return next({...rest, error, type: FAILURE});\r\n                                })\r\n                        );\r\n                    });\r\n            } else {\r\n                // fire off the request to show we are making this request\r\n                next({...rest, type: REQUEST});\r\n\r\n                resolvePromise = promise(apiClient, getState)\r\n                    .then(result => {\r\n                        apiClient.resetConfigs();\r\n                        // clear this promise from the queue\r\n                        pending = pending.remove(REQUEST);\r\n                        // send back a success result\r\n                        return next({...rest, result, type: SUCCESS});\r\n                    })\r\n                    .catch(error => {\r\n                        // clear this promise from the queue\r\n                        pending = pending.remove(REQUEST);\r\n                        apiClient.resetConfigs();\r\n                        // send back an error result\r\n                        return next({...rest, error, type: FAILURE});\r\n                    })\r\n            }\r\n\r\n            // set this as request type as pending\r\n            pending = pending.set(REQUEST, resolvePromise);\r\n\r\n            return resolvePromise;\r\n        };\r\n    };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}